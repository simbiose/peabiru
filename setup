#!/bin/bash

#
# deploy script
#
# @author    xico@simbio.se
# @copyright Simbiose
# @license   LGPL version 3.0, see LICENSE
#

ENV=$1
DEPLOY=deploy.conf
CONTAINER=peabiru

function err {
  echo "$(tput bold)$(tput setaf 1)$(tput setab 0)$1$(tput sgr0)" >&2
  [ -z $2 ] || exit 1
}

function puts {
  printf "$(tput bold)$(tput setaf 4)$(tput setab 0)$1$(tput sgr0)${2-\\n}"
}

[ $BASH_VERSINFO -lt 4 ] && err "sorry, you need at least bash 4." true

declare -A CONF
declare -A ini_kv
declare -a INVALID
declare -a ini_sections
declare -a ini_keys

# read/parse ini files
# [file]

function ini.parse {
  [ -f $1 ] || return 1
  local section order=0 order2=0
  while read line; do
    [[ $line =~ ^\s*$ ]] && continue
    if [[ $line =~ ^\[(.*)\] ]]; then
      section="${BASH_REMATCH[1]//[[:space:]]/}"
      ini_sections[$((order++))]="$section"
    elif [[ $line =~ ^([^[:space:]]*)[[:space:]](.*)$ ]]; then
      ini_kv["${section}_${BASH_REMATCH[1]//[[:space:]]/}"]="${BASH_REMATCH[2]}"
      ini_keys[$((order2++))]="${section}_${BASH_REMATCH[1]//[[:space:]]/}"
    fi
  done < $1
  return 0
}

# iterate over ini, delete and add keys and values pairs
# [action(add|del|get)], [section], [key], [value]

function ini.key {
  [[ -n $3 && "add" == $1 || "del" == $1 || "get" == $1 ]] || return 1
  [ $1 == "add" ] && {
    [ -z ${ini_kv["${2}_${3}"]} ] && ini_keys+=( "${2}_${3}" )
    ini_kv["${2}_${3}"]="$4"
  } || { [ "get" == $1 ] && echo ${ini_kv["${2}_${3}"]} || unset ini_kv["${2}_${3}"]; }
}

# save options to ini file
# [file]

function ini.save {
  local section key order
  for order in "${!ini_sections[@]}"; do
    section=${ini_sections[$order]}
    [ $order -eq 0 ] && echo -e "[$section]" > $1 || echo -e "\n[$section]" >> $1
    for key in "${ini_keys[@]}"; do
      [[ $key == "${section}_"* && -n ${ini_kv[$key]} ]] && \
        echo -e "${key#${section}_} ${ini_kv[$key]}" >> $1
    done
  done
  for k in ${!ini_kv[@]}; do unset ini_kv["$k"]; done
  unset ini_sections
  unset ini_keys
  return 0
}

# commmand exists?

function exists {
  command -v $1 >/dev/null 2>&1 || \
    { [ -z "$2" ] && { err "script require '$1' to run!"; exit 1; } || return 1; }
  return 0
}

# ask

function ask {
  echo -n "$1 "
  read answer
  [ "$answer" == "$2" ]
}

# ask config, replace existing and/or create

function config {
  answer="$3"
  key="${1//-/}"
  [ -z "$answer" ] && answer="$(ini.key get $ENV $key)"
  [[ -n "$2" && -z "$answer" ]] && {
    echo -n "$2"
    read answer
    ini.key add
  }
  [ -n "$answer" ] && {
    ini.key add $ENV $key "$answer"
    CONF[${key^^}]="$answer"
  }
}

# stdin vars expand, like envsubst

function subs {
  line="$(cat; echo -n a)"
  end_offset=${#line}
  while [[ "${line:0:$end_offset}" =~ (.*)(\$\{([a-zA-Z_][a-zA-Z_0-9/\.\-]*)\})(.*) ]]; do
    [[ "${BASH_REMATCH[3]}" == *"-"* ]] && {
      first_part=$(echo ${BASH_REMATCH[3]} | cut -d'-' -f 1)
      [ -n "${CONF[$first_part]}" ] && {
        last_part="-"$(echo ${BASH_REMATCH[3]} | cut -d'-' -f 2-999)
        eval 'VARVAL="${CONF[$first_part]$last_part}"'
      }
    } || {
      [ -n "${CONF[${BASH_REMATCH[3]}]}" ] && \
        eval 'VARVAL="${CONF[${BASH_REMATCH[3]}]}"' || eval 'VARVAL="${'${BASH_REMATCH[3]}'}"'
    }
    line="${BASH_REMATCH[1]}$VARVAL${BASH_REMATCH[4]}${line:$end_offset:${#line}}"
    end_offset=${#BASH_REMATCH[1]}
  done
  echo -n "${line:0:-1}"
}

function isinstalled { docker ps -a | grep $CONTAINER > /dev/null; }
function isrunning { docker ps | grep $CONTAINER > /dev/null; }
function isproduction { [ $ENV = "production" ]; }
function isdev { [ $ENV = "development" ]; }

#
# action ...
#

[[ -n $TERM && $TERM = unknown ]] && TERM=dumb
[[ -f $DEPLOY ]] || err "could not locate ${DEPLOY}, aborting" true

# docker, docker-compose [deploy] exists?
exists docker
exists docker-compose

ini.parse $DEPLOY

# match agains environments
if [ -z $ENV ]; then
  err "first argument should be the environment, default to ${ini_sections[0]}"
  ENV=${ini_sections[0]}
elif [[ " ${ini_sections[*]} " != *" $ENV "* ]]; then
  list=$(printf ", %s" ${ini_sections[@]#${ini_sections[-1]}})" or ${ini_sections[-1]}"
  err "environment should be:${list:1}" true
fi

# expand config vars
CURRENT=$(pwd)
DB_PWD=$(< /dev/urandom tr -dc A-Za-z0-9 | head -c ${1:-16})
isdev && SHARED=$(mkdir -p $CURRENT/shared && cd $CURRENT/shared && pwd) || \
  SHARED=$(cd $CURRENT/../shared && pwd)

CONF+=( [CURRENT]=$CURRENT [SHARED]=$SHARED [DB_PWD]=$DB_PWD [ENV]=$ENV )

# get options ...
while test $# -gt 3; do
  case "$3" in
      --smtp_host|--smtp_port|--smtp_user|--smtp_pwd|--mapbox_token|--osm_key| \
      --osm_secret|--twitter_key|--twitter_secret|--github_id|--github_secret| \
      --google_id|--google_secret|--facebook_id|--facebook_secret \
    )
      config $3 "" $4
      shift
      ;;
    *)
      [[ "$3" == "-"* ]] && INVALID+=("$3")
      ;;
  esac
  shift
done

for opt in ${INVALID[@]}; do
  puts " invalid option: ${opt}"
done

config host "Please input host name: "
config db_host "Please input database host: "
config db_user "Please input database user: "
config db_name "Please input database name: "
config smtp_host "Please input SMTP host: "
config smtp_port "Please input SMTP port: "
config smtp_user "Please input SMTP user: "
config smtp_pwd "Please input STMP password: "
config mapbox_token "Please input Mapbox API token: "
config osm_key "Please input OpenStreeMap API key: "
config osm_secret "Please input OpenStreeMap API secret: "
config twitter_key "Please input Twitter API key: "
config twitter_secret "Please input Twitter API secret: "
config facebook_id "Please input Facebook API id: "
config facebook_secret "Please input Facebook API secret: "
config google_id "Please input Google API id: "
config google_secret "Please input Google API secret: "
config github_id "Please input Github API id: "
config github_secret "Please input Github API secret: "

ini.save $DEPLOY

# drop database [rollback]
function rollback {
  ask "Are you sure to rollback database? y or n" 'y' || exit 0;
  puts " [database rollback] ... "
  docker exec -i $CONTAINER /bin/bash -c \
    "dropdb -U ${CONF[DB_USER]} -h ${CONF[DB_HOST]} ${CONF[DB_NAME]} && sleep 10 && \
    createdb -U ${CONF[DB_USER]} -h ${CONF[DB_HOST]} ${CONF[DB_NAME]}"
}

# migrate schema
function migrate {
  puts " [schema migration] ... "
  docker exec -i $CONTAINER /bin/bash -c \
    "psql -h ${CONF[DB_HOST]} -U ${CONF[DB_USER]} -d ${CONF[DB_NAME]} < ${CURRENT}/schema.sql"
}

# start/install
function start {
  puts " [starting] ... " ""
  isrunning && puts "\\r already started" || {
    isinstalled && {
      docker start $CONTAINER
    } || {
      rm -rf $SHARED/{logs,tmp,data,sock,pids}
      mkdir -p $SHARED/{logs,tmp,data,sock,pids}
      :>${CURRENT}/config/.env
      for k in ${!CONF[@]}; do
        [[ "${CONF[$k]}" = *\ * ]] && echo "${k}=\"${CONF[$k]}\"" >> ${CURRENT}/config/.env || \
          echo "${k}=${CONF[$k]}" >> ${CURRENT}/config/.env
      done
      sleep 2
      subs < compose.yml | docker-compose -f - up -d && puts "\\r started "
    }
  }
}

# stop
function stop {
  puts " [stoping] ... " ""
  isrunning && {
    docker stop $CONTAINER && puts "\\r stopped "
  } || puts "\\r already stopped "
}

# set of actions
function action {
  case "$1" in
    start)    start; ;;
    stop)     stop; ;;
    restart)  stop && sleep 10 && start; ;;
    migrate)  migrate; ;;
    reset)    rollback && sleep 10 && migrate; ;;
    rollback) rollback; ;;
    *)        start && exit 1;
  esac
  return 0
}

# run!
[ -n $2 ] && action $2 || {
  [ $ENV == "development" ] && start
}
