#!/bin/bash

#
# deploy script
#
# @author    xico@simbio.se
# @copyright Simbiose
# @license   LGPL version 3.0, see LICENSE
#

ENV=$1
DEPLOY=deploy.conf
CONTAINER=peabiru

function err {
  echo "$(tput bold)$(tput setaf 1)$(tput setab 0)$1$(tput sgr0)" >&2
  [ -z $2 ] || exit 1
}

function puts {
  printf "$(tput bold)$(tput setaf 4)$(tput setab 0)$1$(tput sgr0)${2-\\n}"
}

[ $BASH_VERSINFO -lt 4 ] && err "sorry, you need at least bash 4." true

declare -A CONF
declare -A ini_kv
declare -a ini_sections
declare -a ini_keys

# read/parse ini files
# [file]

function ini.parse {
  [ -f $1 ] || return 1
  local section order=0 order2=0
  while read line; do
    [[ $line =~ ^\s*$ ]] && continue
    if [[ $line =~ ^\[(.*)\] ]]; then
      section="${BASH_REMATCH[1]//[[:space:]]/}"
      ini_sections[$((order++))]="$section"
    elif [[ $line =~ ^([^[:space:]]*)[[:space:]](.*)$ ]]; then
      ini_kv["${section}_${BASH_REMATCH[1]//[[:space:]]/}"]="${BASH_REMATCH[2]}"
      ini_keys[$((order2++))]="${section}_${BASH_REMATCH[1]//[[:space:]]/}"
    fi
  done < $1
  return 0
}

# iterate over ini, delete and add keys and values pairs
# [action(add|del|get)], [section], [key], [value]

function ini.key {
  [[ -n $3 && "add" == $1 || "del" == $1 || "get" == $1 ]] || return 1
  [ $1 == "add" ] && { ini_kv["${2}_${3}"]="$4"; ini_keys+=( "${2}_${3}" ); } \
    || { [ "get" == $1 ] && echo ${ini_kv["${2}_${3}"]} || unset ini_kv["${2}_${3}"]; }
}

# save options to ini file
# [file]

function ini.save {
  local section key order
  for order in "${!ini_sections[@]}"; do
    section=${ini_sections[$order]}
    [ $order -eq 0 ] && echo -e "[$section]" > $1 || echo -e "\n[$section]" >> $1
    for key in "${ini_keys[@]}"; do
      [[ $key == "${section}_"* && -n ${ini_kv[$key]} ]] && \
        echo -e "${key#${section}_} ${ini_kv[$key]}" >> $1
    done
  done
  for k in ${!ini_kv[@]}; do unset ini_kv["$k"]; done
  unset ini_sections
  unset ini_keys
  return 0
}

# commmand exists?

function exists {
  command -v $1 >/dev/null 2>&1 || \
    { [ -z "$2" ] && { err "script require '$1' to run!"; exit 1; } || return 1; }
  return 0
}

# ask config, replace existing and/or create

function config {
  answer="$(ini.key get $ENV $1)"
  if [[ -n "$2" && -z "$answer" ]]; then
    echo -n "$2"
    read answer
    [ -n "$answer" ] && ini.key add $ENV $1 "$answer"
  fi
  [ -n "$answer" ] && CONF["${1^^}"]="$answer"
}

# stdin vars expand, like envsubst

function subs {
  line="$(cat; echo -n a)"
  end_offset=${#line}
  while [[ "${line:0:$end_offset}" =~ (.*)(\$\{([a-zA-Z_][a-zA-Z_0-9/\.\-]*)\})(.*) ]]; do
    [[ "${BASH_REMATCH[3]}" == *"-"* ]] && {
      first_part=$(echo ${BASH_REMATCH[3]} | cut -d'-' -f 1)
      [ -n "${CONF[$first_part]}" ] && {
        last_part="-"$(echo ${BASH_REMATCH[3]} | cut -d'-' -f 2-999)
        eval 'VARVAL="${CONF[$first_part]$last_part}"'
      }
    } || {
      [ -n "${CONF[${BASH_REMATCH[3]}]}" ] && \
        eval 'VARVAL="${CONF[${BASH_REMATCH[3]}]}"' || eval 'VARVAL="${'${BASH_REMATCH[3]}'}"'
    }
    line="${BASH_REMATCH[1]}$VARVAL${BASH_REMATCH[4]}${line:$end_offset:${#line}}"
    end_offset=${#BASH_REMATCH[1]}
  done
  echo -n "${line:0:-1}"
}

function isinstalled { docker ps -a | grep $CONTAINER > /dev/null; }
function isrunning { docker ps | grep $CONTAINER > /dev/null; }
function isproduction { [ $ENV = "production" ]; }
function isdev { [ $ENV = "development" ]; }

#
# action ...
#

[[ -n $TERM && $TERM = unknown ]] && TERM=dumb
[[ -f $DEPLOY ]] || err "could not locate ${DEPLOY}, aborting" true

# docker, docker-compose [deploy] exists?
exists docker
exists docker-compose

ini.parse $DEPLOY

# match agains environments
if [ -z $ENV ]; then
  err "first argument should be the environment, default to ${ini_sections[0]}"
  ENV=${ini_sections[0]}
elif [[ " ${ini_sections[*]} " != *" $ENV "* ]]; then
  list=$(printf ", %s" ${ini_sections[@]#${ini_sections[-1]}})" or ${ini_sections[-1]}"
  echo "environment should be:${list:1}"
fi

# not dev, deploy script should exists
isdev || exists deploy

# expand config vars
CURRENT=$(pwd)
DB_PWD=$(< /dev/urandom tr -dc A-Za-z0-9 | head -c ${1:-16})
isdev && SHARED=$(mkdir -p $CURRENT/shared && cd $CURRENT/shared && pwd) || \
  SHARED=$(cd $CURRENT/../shared && pwd)

CONF+=( [CURRENT]=$CURRENT [SHARED]=$SHARED [DB_PWD]=$DB_PWD )

config host "Please input host name: "
config db_host "Please input database host: "
config db_user "Please input database user: "
config db_name "Please input database name: "
config smtp_host "Please input SMTP host: "
config smtp_post "Please input SMTP post: "
config smtp_user "Please input SMTP user: "
config smtp_pwd "Please input STMP password: "
config mapbox_token "Please input Mapbox API token: "
config osm_key "Please input OpenStreeMap API key: "
config osm_secret "Please input OpenStreeMap API secret: "
config twitter_key "Please input Twitter API key: "
config twitter_secret "Please input Twitter API secret: "
config fb_id "Please input Facebook API id: "
config fb_secret "Please input Facebook API secret: "
config google_id "Please input Google API id: "
config google_secret "Please input Google API secret: "
config github_id "Please input Github API id: "
config github_secret "Please input Github API secret: "

ini.save $DEPLOY

# migrate
function migrate {
  echo " should migrate ... "
}

# start/install
function start {
  puts " [starting] ... " ""
  isrunning && {
    puts "\\r already started"
    return 1
  } || {
    isinstalled && {
      docker start $CONTAINER
    } || {
      rm -rf $SHARED/{logs,tmp,data,sock,pids}
      mkdir -p $SHARED/{logs,tmp,data,sock,pids}
      :>${CURRENT}/config/.env
      for k in ${!CONF[@]}; do
        [[ "${CONF[$k]}" = *\ * ]] && echo "${k}=\"${CONF[$k]}\"" >> ${CURRENT}/config/.env || \
          echo "${k}=${CONF[$k]}" >> ${CURRENT}/config/.env
      done
      sleep 2
      subs < compose.yml | docker-compose -f - up -d && puts "\\r started "
    }
  }
}

# stop
function stop {
  puts " [stoping] ... " ""
  isrunning && {
    docker stop $CONTAINER && puts "\\r stopped "
  } || {
    puts "\\r already stopped "
    return 1
  }
}

# set of actions
function action {
  case "$1" in
    start)   start; ;;
    stop)    stop; ;;
    restart) stop && sleep 10 && start; ;;
    migrate) migrate; ;;
    *)       start && exit 1;
  esac
}

# run!
[ -n $2 ] && action $2 || {
  [ $ENV == "development" ] && start
}
